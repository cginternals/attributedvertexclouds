#version 400

layout (isolines, equal_spacing) in;

patch in Attributes
{
    vec3  position;
    int   type;
    vec3  incoming;
    vec3  outgoing;
    float colorValue;
    float sizeValue;
} attributes;

uniform sampler1D gradient;

out Vertex
{
    vec3 center;
    vec3 normal;
    vec3 bitangent;
    vec3 color;
    int type;
} vertex;

// gl_TessLevelOuter[0] : subdivision count on one line
// gl_TessLevelOuter[1] : number of lines
// gl_TessCoord.x : coordinate on line [0, 1.0)
// gl_TessCoord.y : number of line [0, 1.0)

void main()
{
    vec2 offset = vec2(1.0) / vec2(gl_TessLevelOuter[0], gl_TessLevelOuter[1]);
    vec3 color = texture(gradient, attributes.colorValue).rgb;
    
    vertex.center = attributes.position;
    vertex.type = attributes.type;
    vertex.color = color;
    
    if (attributes.type == 1 || (length(attributes.incoming) <= 0.01 && length(attributes.outgoing) <= 0.01)) // sphere / splat
    {
        gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
        
        vec3 normal = vec3(0.0, 1.0, 0.0) * attributes.sizeValue;
        vec3 tangent = vec3(1.0, 0.0, 0.0) * attributes.sizeValue;
        vec3 bitangent = vec3(0.0, 0.0, 1.0) * attributes.sizeValue;
        
        vec3 position = attributes.position;
        
        float pi = 3.141592654;
        float pi2 = 2.0 * pi;
        
        position.x += attributes.sizeValue * cos(pi2 * gl_TessCoord.x) * sin(pi * gl_TessCoord.y);
        position.y += attributes.sizeValue * sin(pi2 * gl_TessCoord.x) * sin(pi * gl_TessCoord.y);
        position.z += attributes.sizeValue * cos(pi * gl_TessCoord.y);
        
        vec3 next_position1 = attributes.position;
        
        next_position1.x += attributes.sizeValue * cos(pi2 * (gl_TessCoord.x + offset.x)) * sin(pi * gl_TessCoord.y);
        next_position1.y += attributes.sizeValue * sin(pi2 * (gl_TessCoord.x + offset.x)) * sin(pi * gl_TessCoord.y);
        next_position1.z += attributes.sizeValue * cos(pi * gl_TessCoord.y);
        
        vec3 next_position2 = attributes.position;
        
        next_position2.x += attributes.sizeValue * cos(pi2 * gl_TessCoord.x) * sin(pi * (gl_TessCoord.y + offset.y));
        next_position2.y += attributes.sizeValue * sin(pi2 * gl_TessCoord.x) * sin(pi * (gl_TessCoord.y + offset.y));
        next_position2.z += attributes.sizeValue * cos(pi * (gl_TessCoord.y + offset.y));
        
        gl_Position = vec4(position, 1.0);
        
        //vertex.tangent = tangent;
        vertex.bitangent = next_position2 - position;
        vertex.normal = cross(tangent, next_position2 - position);
    }
    else if (attributes.type == 2) // tube / line
    {
        vec3 tangent1 = attributes.incoming;
        vec3 tangent2 = attributes.outgoing;
        vec3 bitangent1 = vec3(0.0, 1.0, 0.0);
        vec3 bitangent2 = vec3(0.0, 1.0, 0.0);
        
        if (abs(dot(normalize(bitangent1), normalize(tangent1))) > 0.99)
        {
            bitangent1 = vec3(1.0, 0.0, 0.0) * attributes.sizeValue;
        }
        
        if (abs(dot(normalize(bitangent2), normalize(tangent2))) > 0.99)
        {
            bitangent2 = vec3(1.0, 0.0, 0.0) * attributes.sizeValue;
        }
        
        vec3 normal1 = cross(tangent1, bitangent1);
        vec3 normal2 = cross(tangent2, bitangent2);
        
        bitangent1 = cross(normal1, tangent1);
        bitangent2 = cross(normal2, tangent2);
        
        vec3 tangent = mix(tangent1, tangent2, step(1.0, gl_TessCoord.x));
        vec3 bitangent = mix(bitangent1, bitangent2, step(1.0, gl_TessCoord.x));
        vec3 normal = mix(normal1, normal2, step(1.0, gl_TessCoord.x));
        
        vec3 position = attributes.position;
        position += tangent * (gl_TessCoord.x * 2.0 - 1.0);
        position += bitangent * cos(2 * 3.141592654 * gl_TessCoord.y) + normal * sin(2 * 3.141592654 * gl_TessCoord.y);
        
        gl_Position = vec4(position, 1.0);
        
        //vertex.tangent = tangent;
        vertex.bitangent = bitangent;
        vertex.normal = normal;
    }
    else
    {
        gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
        
        //vertex.tangent = vec3(0.0, 0.0, 0.0);
        vertex.bitangent = vec3(0.0, 0.0, 0.0);
        vertex.normal = vec3(0.0, 0.0, 0.0);
    }
}
