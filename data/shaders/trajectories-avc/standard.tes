#version 400

layout (quads, equal_spacing) in;

patch in CurrentAttributes
{
    vec3  position;
    int   trajectoryID;
    int   type;
    vec3  color;
    float sizeValue;
} currentAttributes;

patch in PreviousAttributes
{
    vec3  position;
    int   trajectoryID;
    int   type;
    vec3  color;
    float sizeValue;
} previousAttributes;

patch in NextAttributes
{
    vec3  position;
    int   trajectoryID;
    int   type;
    vec3  color;
    float sizeValue;
} nextAttributes;

out Vertex
{
    vec3 color;
} vertex;

uniform float colorMixingArea = 0.5;

const float pi = 3.141592654;
const float pi2 = 2.0 * pi;

void main()
{
    vertex.color = currentAttributes.color;
    
    // for lines
    vertex.color = mix(previousAttributes.color, vertex.color, smoothstep(0.0, colorMixingArea, gl_TessCoord.y));
    vertex.color = mix(vertex.color, nextAttributes.color, smoothstep(1.0 - colorMixingArea, 1.0, gl_TessCoord.y));
    
    int neighborType = int(mix(previousAttributes.type, nextAttributes.type, step(0.5, gl_TessCoord.y)));
    int neighborID = int(mix(previousAttributes.trajectoryID, nextAttributes.trajectoryID, step(0.5, gl_TessCoord.y)));
    
    //float ySize = mix(currentAttributes.sizeValue / 2.0, currentAttributes.sizeValue, float(neighborID == currentAttributes.trajectoryID));
    
    vec3 position = currentAttributes.position;
    
    position.x += currentAttributes.sizeValue / 2.0 * cos(pi2 * gl_TessCoord.x) * sin(pi * gl_TessCoord.y);
    position.y += currentAttributes.sizeValue / 2.0 * sin(pi2 * gl_TessCoord.x) * sin(pi * gl_TessCoord.y);
    position.z += currentAttributes.sizeValue / 2.0 * cos(pi * gl_TessCoord.y);
    
    gl_Position = vec4(position, 1.0);
}



/*else if (attributes.type == 2) // tube / line
{
    vec3 tangent1 = attributes.incoming;
    vec3 tangent2 = attributes.outgoing;
    vec3 bitangent1 = vec3(0.0, 1.0, 0.0);
    vec3 bitangent2 = vec3(0.0, 1.0, 0.0);
    
    if (abs(dot(normalize(bitangent1), normalize(tangent1))) > 0.99)
    {
        bitangent1 = vec3(1.0, 0.0, 0.0) * attributes.sizeValue;
    }
    
    if (abs(dot(normalize(bitangent2), normalize(tangent2))) > 0.99)
    {
        bitangent2 = vec3(1.0, 0.0, 0.0) * attributes.sizeValue;
    }
    
    vec3 normal1 = cross(tangent1, bitangent1);
    vec3 normal2 = cross(tangent2, bitangent2);
    
    bitangent1 = cross(normal1, tangent1);
    bitangent2 = cross(normal2, tangent2);
    
    vec3 tangent = mix(tangent1, tangent2, step(1.0, gl_TessCoord.x));
    vec3 bitangent = mix(bitangent1, bitangent2, step(1.0, gl_TessCoord.x));
    vec3 normal = mix(normal1, normal2, step(1.0, gl_TessCoord.x));
    
    vec3 position = attributes.position;
    position += tangent * (gl_TessCoord.x * 2.0 - 1.0);
    position += bitangent * cos(2 * 3.141592654 * gl_TessCoord.y) + normal * sin(2 * 3.141592654 * gl_TessCoord.y);
    
    gl_Position = vec4(position, 1.0);
    
    //vertex.tangent = tangent;
    vertex.bitangent = bitangent;
    vertex.normal = normal;
}
else
{
    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
    
    //vertex.tangent = vec3(0.0, 0.0, 0.0);
    vertex.bitangent = vec3(0.0, 0.0, 0.0);
    vertex.normal = vec3(0.0, 0.0, 0.0);
}*/